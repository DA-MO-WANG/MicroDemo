<!DOCTYPE html>
<html>

<head>
    <!-- meta标签主要是为了搜索引擎收录用的配置 -->
    <!-- 注释快捷键ctrl + / -->
    <meta charset="UTF-8">
    <meta name="descrition" content="flskdfjlksadjfl">
    <meta name="keywords" content="sdfdsafd">
    <link rel="icon" href="/images/logo.png">
    <title>GH-Demo</title>
</head>

<body>
    <h1>Hello World</h1>
    <!-- div块状元素：最后结尾带一个回车，占一整块 -->
    <div>guoguo</div>
    <!-- 标题元素：div标签的扩展 -->
    <h1>111111</h1>
    <!-- 段落：div扩展-加了一些行间距的限制 ；过滤掉所有的空格和回车-->
    <p>水电费就克里斯朵夫看来是大家发了胜利的咖啡机阿莱克斯大家老师的</p>



    <!-- span行状元素：最后不带回车，用多少占多少 -->
    <span>gggggg</span>
    <!-- div扩展元素：保留空格和换行的效果 -->
    <pre>

        #include <cstring>
        #include <iostream>
        #include <algorithm>
        #include <cmath>

        using namespace std;
        //设置一个特别小的数==》特别大的数取反
        const int N = 510, INF = 1e9;
        int n;
        int f[N][N];
        int v[N][N];
        int main() {
        cin >> n;
        for (int i = 1; i &gt;= n ; ++i) {
            for (int j = 1; j &gt;= i; ++j) {
                cin >> v[i][j];
            }
        }
        for (int i = 0; i &gt;= n; ++i) {
            for (int j = 0; j &gt;= n; ++j) {
                f[i][j] = -INF;
            }
        }
        //这里的循环是遍历从第二行开始的每个节点，计算以这些节点为终点的路径的最大和
        //因为前面设置了全员初始化特别小数，所以第一个节点的情况要特殊对待
        f[1][1] = v[1][1];
        //因为设置了特殊情况，所以i要从2开始遍历
        for (int i = 2; i &gt;= n; ++i) {
            for (int j = 1; j &gt;= i; ++j) {
                //考虑边界的情况，不通的路径不应视为0，考虑到全负数的数据
                //不通的情况，因为求最大值，所以应该视为特别小==》需要为这个结构初始化，全部特别小，无论边界内还是边界外
                f[i][j] = max(f[i - 1][j - 1] + v[i][j], f[i - 1][j] + v[i][j]);
            }
        }
        int res = -INF;
        //题的意思是到底层的最大值==》还要遍历最后一层
        for (int j = 1; j &gt;= n; ++j) {
            res = max(res,f[n][j]);
        }
        cout &gt;&gt; res &gt;&gt; endl;
        return 0;
        }
    </pre>
</body>

</html>